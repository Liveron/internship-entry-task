# Tic Tac Toe
## Описание API 
Документация API доступна в SwaggerUI после запуска проекта с помощью docker compose: http://localhost:8080/swagger

## Архитектурные решения
### Event Sourcing
Для реализации игры "Крестики-нолики" был применен упрощенный вариант Event Sourcing (без снэпшотов и без CQRS). Вместо традиционного хранения текущего состояния (например, в виде JSON-массива ["X", null, "O", ...] или строкового представления типа "X__0X__X_"), система сохраняет последовательность событий — ходов игроков.

#### Преимущества подхода:
1. Естественность модели
- Каждое событие содержит минимальные данные.
- Состояние доски вычисляется путем применения всех событий по порядку.

2. Расширяемость
- При необходимости можно легко реализовать откать хода и просмотр полной истории игр.

### Модульная луковая архитектура с богатой моделью
Для реализации проекта выбрана луковая архитектура с разделением на модули Domain, Infrastructure, (Presentation + Application). Это решение обусловлено следующими факторами:

1. Сложная бизнес-логика
- При использовании слоистой архитектуры пришлось бы либо перегружать контроллеры и сервисы, либо добавлять в модели логику работы с базой данных (в случае неанемичных моделей). В частности, алгоритм игры в крестики-нолики в таком случае стал бы сложным для понимания и поддержки.

2. Управление зависимостями
- Разделение на модули позволяет упростить взаимодействие между компонентами системы и сделать зависимости более прозрачными.

## Технические решения
### Идемпотентность и concurrency
Для предотвращения конфликтов при параллельном изменении состояния игры реализован механизм оптимистичной блокировки:

1. Проверка версии через If-Match. Каждый запрос на изменение должен содержать заголовок `If-Match` с ожидаемой версией игры. Сервер сравнивает ее с актуальной версией:
```
var expectedVersion = _httpContext.GetRequestIfMatchVersionHeader();
var actualVersion = await _gameRepository.GetGameVersionAsync(gameId);

if (expectedVersion != actualVersion)
   throw new ConcurrencyException(expectedVersion, actualVersion);
```

2. Для защиты от "потерянных обновлений" (когда две транзакции читают одну версию) в PostgreSQL создан составной уникальный индекс на Id игры и ее версию:

```
eventEntryConfiguration.HasIndex(e => new { e.ModelId, e.Version })
   .IsUnique();
```

### СУБД и ORM
В качестве СУБД и ORM были выбраны PostgreSQL и Entity Framework Core (выбор из-за опыта работы).
Для Event Sourcing также подошли бы специализированные решения (например, EventStoreDB).

## Настройка
Для изменения размера доски и условия победы необходимо добавить переменные окружения `TABLE_SIZE` и `WIN_LENGTH` соответственно. 